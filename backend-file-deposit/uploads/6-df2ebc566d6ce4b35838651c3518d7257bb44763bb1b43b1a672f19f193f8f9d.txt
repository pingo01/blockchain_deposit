#define _CRT_SECURE_NO_WARNINGS
# include <stdio.h>
# include <ctype.h>
# include <string.h>
# include <stdlib.h>


//类别码的助记符（扩展后）
# define BEGIN 1
# define END 2
# define IF 3
# define THEN 4
# define ELSE 5
# define WHILE 6
# define DO 7
# define FOR 8         // 新增关键字，for
# define INT 9         // 新增关键字，整型
# define FLOAT 10      // 新增关键字，单浮点型
# define CHAR 11       // 新增关键字，字符型
# define RETURN 12     // 新增关键字，return
# define ID 13         // 标识符（原8→13）
# define ICON 14       // 整型常量（新增）
# define UCON 15       // 无符号数常量（原9→15，仅含小数/科学计数法）
# define SCON 16       // 字符串常量（新增）
# define LT 17         // <（原10→17）
# define LE 18         // <=（原11→18）
# define EQ 19         // ==（原12→19）
# define NE 20         // <>或!=（原13→20）
# define GT 21         // >（原14→21）
# define GE 22         // >=（原15→22）
# define IS 23         // =（原16→23）
# define PL 24         // +（原17→24）
# define MI 25         // -（原18→25）
# define MU 26         // *（原19→26）
# define DI 27         // /（原20→27）
# define AND 28        // && 逻辑与（新增）
# define OR 29         // || 逻辑或（新增）
# define NOT 30        // ! 逻辑非（新增）
// 新增分隔符/运算符类别码（接之前的30继续定义）
#define SEMICOLON 31   // ; 分号
#define LPAREN 32      // ( 左括号
#define RPAREN 33      // ) 右括号
#define LBRACE 34      // { 左大括号
#define RBRACE 35      // } 右大括号
#define COMMA 36       // , 逗号
#define INC 37         // ++ 自增（针对测试用例中的i++）

/* 建立保留字表 */
# define MAX_TOKEN_LEN 50  // 扩展单词最大长度
# define MAX_KEYWORDS 30   // 扩展关键字最大数量
# define MAX_LINE 1024     // 每行最大字符数
// 全局变量
char TOKEN[MAX_TOKEN_LEN]; // 存储当前单词
FILE* fp_in, * fp_out;       // 输入输出文件指针
int row = 1, col = 0;       // 记录当前字符位置（行、列）

//#define KEY_WORD_END "waiting for your expanding" /*关键字结束标记*/
// 关键字表（含结束标记）
char* KeyWordTable[MAX_KEYWORDS] = { "begin", "end", "if", "then", "else", "while", "do",  "for", "int", "float", "char", "return","KEY_WORD_END" };    //  新增关键字

// 错误类型定义
#define ERR_INVALID_CHAR 1    // 无效字符
#define ERR_SINGLE_DOT 2     // 单独小数点
#define ERR_UNCLOSED_STR 3   // 字符串未闭合
#define ERR_ILLEGAL_ESCAPE 4 // 非法转义字符
#define ERR_SINGLE_LOGIC 5   // 单独&或|

/* 查保留字表，判断是否为关键字 */
//关键字查找函数
//strcmp () 函数用于比较两个字符串的大小，返回值为 0、正数或负数.如果返回值小于 0，则表示 str1 小于 str2。如果返回值大于 0，则表示 str1 大于 str2。如果返回值等于 0，则表示 str1 等于 str2。。	
int lookup(char* token) {
    for (int n = 0; strcmp(KeyWordTable[n], "KEY_WORD_END") != 0; n++) {
        if (strcmp(KeyWordTable[n], token) == 0) {
            return n + 1;  // 返回关键字编码（1-12）
        }
    }
    return 0;  // 非关键字（移到循环外！）
}

//错误报告函数（扩展：位置+类型）
void report_error(int err_type)
{
    const char* err_msg[] = {
        "",
        "无效字符",
        "单独小数点（非法常量）",
        "字符串未闭合",
        "非法转义字符",
        "单独&或|（非法逻辑运算符）"
    };
    fprintf(fp_out, "错误：行%d列%d - %s，字符 '%c'\n",
        row, col, err_msg[err_type], TOKEN[0]);;
}

//结果输出函数（适配扩展类别）
void out(int class_code, char* value) {
    char* mnemonic[] = { "", "BEGIN", "END", "IF", "THEN", "ELSE", "WHILE", "DO",
                         "FOR", "INT", "FLOAT", "CHAR", "RETURN",
                         "ID", "ICON", "UCON", "SCON",
                         "LT", "LE", "EQ", "NE", "GT", "GE", "IS",
                         "PL", "MI", "MU", "DI", "AND", "OR", "NOT",
                         "SEMICOLON", "LPAREN", "RPAREN", "LBRACE", "RBRACE", "COMMA", "INC" }; // 新增31-37
    if (class_code >= 1 && class_code <= 30) {
        if (class_code == ID || class_code == ICON || class_code == UCON) {
            fprintf(fp_out, "(%s, '%s') \n", mnemonic[class_code], value);
        }
        else if (class_code == SCON) {
            fprintf(fp_out, "(%s, %s) \n", mnemonic[class_code], value);
        }
        else {
            fprintf(fp_out, "(%s, ) \n", mnemonic[class_code]);
        }
    }
}


//字符读取函数
char getchar_custom() {
    char ch = fgetc(fp_in);
    if (ch == EOF) {  // 若读取到文件末尾，直接返回EOF，不更新行列号
        return ch;
    }
    // 只有有效字符才更新行列号
    col++;
    if (ch == '\n') {
        row++;
        col = 0;
    }
    return ch;
}

//字符回退函数
void retract() {
    fseek(fp_in, -1, SEEK_CUR);
    col--;
    if (col < 0) {
        row--;
        col = MAX_LINE - 1;  // 简化处理，实际可读取上一行长度
    }
}

//字符拼接函数
void cat(char ch) {
    int len = strlen(TOKEN);
    if (len < MAX_TOKEN_LEN - 1) {
        TOKEN[len] = ch;
        TOKEN[len + 1] = '\0';
    }
}

/* 词法分析核心函数（扩展功能实现） */
void scanner() {
    char ch;
    int c;
    while (1) {
        ch = getchar_custom();  // 读取字符（可能是EOF）

        // 若读取到文件末尾，立即退出循环
        if (ch == EOF) {
            break;
        }

        // 跳过空白字符（此时ch一定是有效字符，非EOF）
        if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
            continue;
        }

        memset(TOKEN, 0, sizeof(TOKEN));  // 重置TOKEN
        // 识别字母开头的单词（关键字或标识符）
        if (isalpha(ch)) {
            cat(ch);
            while (1) {
                ch = getchar_custom();
                if (ch == EOF) {  // 新增：若读取到EOF，直接退出内层循环
                    break;
                }
                if (isalnum(ch) || ch == '_') { // 标识符支持下划线
                    cat(ch);
                }
                else {
                    retract();  // 非EOF且非字母数字才回退
                    break;
                }
            }
            c = lookup(TOKEN);
            if (c != 0) {
                out(c, "");
            }
            else {
                out(ID, TOKEN);
            }
        }

        // 识别常量（整型、无符号数、字符串）
        else if (isdigit(ch) || ch == '.' || ch == '"') {
            if (ch == '"') {  // 字符串常量
                cat(ch);
                while (1) {
                    ch = getchar_custom();
                    if (ch == EOF) {
                        report_error(ERR_UNCLOSED_STR);
                        break;
                    }
                    cat(ch);
                    if (ch == '"') {
                        out(SCON, TOKEN);
                        break;
                    }
                    if (ch == '\\') {  // 处理\"转义
                        ch = getchar_custom();
                        if (ch == '"') cat(ch);
                        else {
                            retract();
                            report_error(ERR_ILLEGAL_ESCAPE);
                            break;
                        }
                    }
                }
            }
            else {  // 整型或无符号数
                int has_dot = 0, has_e = 0;
                cat(ch);
                if (ch == '.') has_dot = 1;

                while (1) {
                    ch = getchar_custom();
                    if (ch == EOF) break;
                    if (isdigit(ch)) {
                        cat(ch);
                    }
                    else if (ch == '.' && !has_dot && !has_e) {
                        cat(ch);
                        has_dot = 1;
                    }
                    else if ((ch == 'e' || ch == 'E') && !has_e) {
                        cat(ch);
                        has_e = 1;
                        ch = getchar_custom();
                        if (ch == '+' || ch == '-') cat(ch);
                        else retract();
                    }
                    else {
                        retract();
                        break;
                    }
                }
                if (!has_dot && !has_e) {
                    out(ICON, TOKEN);
                }
                else if (strlen(TOKEN) == 1 && TOKEN[0] == '.') {
                    report_error(ERR_SINGLE_DOT);
                }
                else {
                    out(UCON, TOKEN);
                }
            }
        }

        // 识别关系运算符+赋值符
        else if (ch == '>') {
            ch = getchar_custom();
            if (ch == EOF) {  // 新增：若读取到EOF，直接视为 '>'
                out(GT, "");
                break;  // 退出当前解析逻辑
            }
            if (ch == '=') {
                out(GE, "");
            }
            else {
                retract();
                out(GT, "");
            }
        }
        else if (ch == '=') {
            ch = getchar_custom();
            if (ch == EOF) {  // 处理EOF：单独的'=', 不回退
                out(IS, "");
            }
            else if (ch == '=') {
                out(EQ, "");
            }
            else {
                retract();  // 非EOF且非'=', 回退
                out(IS, "");
            }
        }

        // 识别逻辑运算符（新增）
        else if (ch == '!')
        {
            ch = getchar_custom();
            if (ch == '=')
                out(NE, "");
            else if (ch == EOF)
                out(NOT, "");
            else {
                retract();
                out(NOT, "");
            }
        }
        // 修正逻辑运算符识别（原代码中对空格的误判）
        else if (ch == '&') {
            ch = getchar_custom();
            if (ch == '&') {
                out(AND, "");
            }
            else {
                retract();
                if (ch != ' ') {  // 仅非空格才报错
                    report_error(ERR_SINGLE_LOGIC);
                }
            }
        }
        else if (ch == '|') {
            ch = getchar_custom();
            if (ch == '|') {
                out(OR, "");
            }
            else {
                retract();
                if (ch != ' ') {  // 仅非空格才报错
                    report_error(ERR_SINGLE_LOGIC);
                }
            }
        }

        // 识别算术运算符+注释（新增注释处理）
        else if (ch == '+') {
            out(PL, "");
        }
        else if (ch == '-') {
            out(MI, "");
        }
        else if (ch == '*') {
            out(MU, "");
        }
        else if (ch == '/') {
            ch = getchar_custom();
            if (ch == '/') {  // // 单行注释
                while (1) {
                    ch = getchar_custom();
                    if (ch == '\n' || ch == EOF) break;
                }
            }
            else {
                retract();
                out(DI, "");
            }
        }
        // 识别分号、括号、大括号、逗号（新增）
        else if (ch == ';') {
            out(SEMICOLON, "");
}
        else if (ch == '(') {
            out(LPAREN, "");
}
        else if (ch == ')') {
            out(RPAREN, "");
}
        else if (ch == '{') {
            out(LBRACE, "");
}
        else if (ch == '}') {
            out(RBRACE, "");
            }
        else if (ch == ',') {
                out(COMMA, "");
                }
                // 识别自增运算符++（新增，针对i++）
        else if (ch == '+') {
                 ch = getchar_custom();
                  if (ch == '+') {
                      out(INC, "");  // 自增
                    }
                    else {
                        retract();
                        out(PL, "");   // 普通加号
                    }
                  }
        // 无效字符
        else {
            cat(ch);
            report_error(ERR_INVALID_CHAR);
        }
    }
}

int main() {
    // 检查命令行参数
    // 打开文件
    fp_in = fopen("C:/Users/mrf/source/repos/cffxtz/cffxtz/input1.txt", "r");
    if (fp_in == NULL) {
        perror("打开输入文件失败");
        return 1;
    }

    fp_out = fopen("C:/Users/mrf/source/repos/cffxtz/cffxtz/output1.txt", "w");
    if (fp_out == NULL) {
        perror("打开输出文件失败");
        fclose(fp_in);
        return 1;
    }

    // 执行词法分析
    scanner();

    // 关闭文件
    fclose(fp_in);
    fclose(fp_out);
    printf("词法分析完成，结果已保存到 %s\n", "C:/Users/mrf/source/repos/cffxtz/cffxtz/output1.txt");
    return 0;
}